<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Block Encoder / Decoder (Keyed)</title>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Literata:ital,wght@0,400;0,600;1,400&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">

<style>
/* --- Base reset --- */
* { box-sizing: border-box; margin: 0; padding: 0; }
:root{
  --bg-primary: #0a0e14;
  --bg-secondary: #141920;
  --bg-tertiary: #1a1f28;
  --accent: #6ee7b7;
  --accent-dim: #34d399;
  --text-primary: #e8eaed;
  --text-secondary: #9ca3af;
  --border: #2d3748;
  --shadow: rgba(0,0,0,0.45);
}
body{
  font-family: 'Literata', serif;
  background: var(--bg-primary);
  color: var(--text-primary);
  min-height: 100vh;
  padding: 2rem 1rem;
  -webkit-font-smoothing:antialiased;
}
.container{ max-width: 1100px; margin: 0 auto; }
header{ margin-bottom: 2.25rem; }
h1{ font-size: 2rem; font-weight: 600; background: linear-gradient(135deg,var(--text-primary),var(--accent)); -webkit-background-clip:text; -webkit-text-fill-color:transparent; margin-bottom: 0.5rem; }
.subtitle{ color:var(--text-secondary); font-size:0.95rem; font-style:italic; }

.section{
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-radius: 14px;
  padding: 2.25rem;
  margin-bottom: 1.5rem;
  box-shadow: 0 10px 34px rgba(0,0,0,0.58);
}

/* de-emphasize the small key row so the split becomes the focal point */
.section:first-of-type{
  background: transparent;
  border: 0;
  padding: 0.6rem 0;
  box-shadow: none;
  display: flex;
  align-items: center;
  gap: 1rem;
}
.section:first-of-type label{ color:var(--text-secondary); text-transform:none; font-weight:600; font-size:0.95rem; }
.section:first-of-type input{ max-width:520px; margin-left:auto; background:rgba(255,255,255,0.02); }

label{ display:flex; justify-content:space-between; align-items:center; margin-bottom:0.6rem; font-weight:600; color:var(--accent); text-transform:uppercase; font-size:0.85rem; }
.label-text{ flex:1; }
.char-count{ font-family:'JetBrains Mono', monospace; font-size:0.78rem; color:var(--text-secondary); font-weight:400; }

input, textarea{ width:100%; padding:1.1rem 1.2rem; background:var(--bg-tertiary); border:1px solid var(--border); border-radius:12px; color:var(--text-primary); font-family:'JetBrains Mono', monospace; font-size:1.02rem; resize:vertical; }
input:focus, textarea:focus{ outline:none; border-color:var(--accent); box-shadow:0 0 0 6px rgba(110,231,183,0.06); background:linear-gradient(180deg, rgba(255,255,255,0.01), var(--bg-secondary)); }

/* emphasize the two main columns (larger, more generous spacing) */
.column textarea{ min-height:520px; font-size:1.06rem; padding:1.25rem; line-height:1.8; border-radius:14px; }
@media (max-width:980px){ .column textarea{ min-height:320px; } }

textarea{ min-height:140px; line-height:1.6; }

.button-group{ display:flex; gap:0.75rem; margin-top:1rem; }

/* split layout for encode ↔ decode columns — equal-width columns */
.split{ display:grid; grid-template-columns: 1fr 1fr; gap:3rem; align-items:start; }
.column{ min-width:0; display:flex; flex-direction:column; gap:0.6rem; }
@media (max-width:980px){ .split{ grid-template-columns: 1fr; gap:1rem; } }

button{ flex:1; padding:0.8rem 1rem; background:var(--bg-tertiary); border:1px solid var(--border); border-radius:10px; color:var(--text-primary); font-weight:600; cursor:pointer; transition:all 0.18s ease; position:relative; overflow:hidden; }
button.primary{ background: linear-gradient(135deg,var(--accent-dim),var(--accent)); border-color:var(--accent); color:var(--bg-primary); }
button:active{ transform:translateY(0); }
button::before{ content:''; position:absolute; top:50%; left:50%; width:0; height:0; border-radius:50%; background:rgba(110,231,183,0.08); transform:translate(-50%,-50%); transition:width .35s ease,height .35s ease; }
button:hover::before{ width:300px; height:300px; }

.compression-stats{ margin-top:1rem; padding:0.9rem; background:var(--bg-primary); border:1px solid var(--border); border-radius:8px; display:none; }
.compression-stats.visible{ display:block; }
.stat-row{ display:flex; justify-content:space-between; align-items:center; margin-bottom:0.45rem; }
.stat-label{ color:var(--text-secondary); font-size:0.88rem; }
.stat-value{ font-family:'JetBrains Mono', monospace; font-weight:600; }
.stat-value.positive{ color:var(--accent); }
.stat-value.negative{ color:#f87171; }

.success-indicator{ position:fixed; top:1.75rem; right:1.75rem; background:var(--accent); color:var(--bg-primary); padding:0.6rem 1rem; border-radius:8px; font-weight:700; opacity:0; transform:translateY(-8px); transition:all .28s ease; pointer-events:none; }
.success-indicator.show{ opacity:1; transform:translateY(0); }

@media (max-width:640px){ body{ padding:1rem; } h1{ font-size:1.6rem; } .button-group{ flex-direction:column; } }
</style>
</head>

<body>
<div class="container">
  <header>
    <h1>Block Cipher</h1>
    <div class="subtitle">Compress and encrypt text with visual encoding</div>
  </header>

  <div class="section">
    <label>Encryption Key</label>
    <input id="keyInput" type="text" placeholder="Optional passphrase for encoding">
  </div>

  <div class="section">
    <div class="split">
      <div class="column">
        <label>
          <span class="label-text">Input Text</span>
          <span class="char-count" id="originalSize">0 characters</span>
        </label>
        <textarea id="textInput" placeholder="Enter text to encode..."></textarea>
      </div>

      <div class="column">
        <label>
          <span class="label-text">Encoded Blocks</span>
          <span class="char-count" id="encodedCount">0 characters</span>
        </label>
        <!-- editable so users can paste/modify encoded blocks -->
        <textarea id="encodedOutput" placeholder="Encoded text will appear here..."></textarea>

        <div class="compression-stats" id="compressionStats">
          <div class="stat-row">
            <span class="stat-label">Original Size</span>
            <span class="stat-value" id="originalSize">0</span>
          </div>
          <div class="stat-row">
            <span class="stat-label">Encoded Size</span>
            <span class="stat-value" id="encodedSize">0</span>
          </div>
          <div class="stat-row">
            <span class="stat-label">Compression</span>
            <span class="stat-value" id="compressionPercent">0%</span>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<div id="successIndicator" class="success-indicator">Copied!</div>

<script>
// ================= CONFIG =================

// Paste your big blockChars array here
// Generate printable Unicode dynamically
const blockChars = (() => {
  const out = [];

  for (let cp = 0x21; cp <= 0x10FFFF; cp++) {
    // skip surrogates
    if (cp >= 0xD800 && cp <= 0xDFFF) continue;

    const ch = String.fromCodePoint(cp);

    // reject whitespace
    if (/\s/.test(ch)) continue;

    // reject control / format
    if (/[\p{Cc}\p{Cf}]/u.test(ch)) continue;

    // reject combining marks
    if (/\p{Mn}|\p{Me}/u.test(ch)) continue;

    out.push(ch);
  }

  return out;
})();

const bigrams = [
  "th","he","in","er","an","re","on","at","en","nd",
  "ti","es","or","te","of","ed","is","it","al","ar",
  "st","to","nt","ng","se","ha","as","ou","io","le",
  "ve","co","me","de","hi","ri"
];

const DICT = [
  // space aware
  " the ", " and ", " to ", " of ", " in ", " for ", " with ", " on ", " that ",
  " is ", " was ", " are ", " be ", " have ", " not ", " it ", " this ", " you ",

  // core trigrams
  "the","and","ing","ion","tio","ent","for","tha","ati","her","ter","ere","ate",
  "his","con","res","ver","all","nce","men","ith","ted","ers","pro","thi","wit",
  "are","ess","not","ive","was","ect","rea","com","eve","per","int","est","sta",

  // bigrams (real English only)
  "th","he","in","er","an","re","on","at","en","nd","ti","es","or","te","of","ed",
  "is","it","al","ar","st","to","nt","ng","se","ha","as","ou","io","le","ve","co",

  // suffixes
  "ing ","tion", "ness ", "ive","ity ",


  // common short words
  "the","and","for","you","with","this","that","have","from","they","your","were",
  "which","their","there","would","could","should",

  // punctuation patterns
  ". ", ", ", "? ", "! ", "\n\n"
].sort(function(a, b) {
  return b.length - a.length;
});

const setsForHuffman = [
  "e",
  "t",
  "a",
  "o",
  "i",
  "n",
  "s",
  "h",
  "r",
  "d",
  "l",
  "c",
  "u",
  "m",
  "w",
  "f",
  "g",
  "y",
  "p",
  "b",
  "v",
  "k"
]

// map allowed chars to small ints
const allowedChars =
"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 !@#$%^&*()-_=+/?.,:\"'<>[]{}\\|;\n\t";

const CHAR_TO_ID = Object.fromEntries([...allowedChars].map((c,i)=>[c,i]));
const ID_TO_CHAR = [...allowedChars];

// dictionary IDs start AFTER chars
const DICT_BASE = allowedChars.length;

// ================= KEY =================

async function sha256ToOffset(str, mod) {
  const data = new TextEncoder().encode(str);
  const hash = await crypto.subtle.digest("SHA-256", data);
  const view = new DataView(hash);
  const high = BigInt(view.getUint32(0));
  const low  = BigInt(view.getUint32(4));
  return Number(((high<<32n)|low) % BigInt(mod));
}

async function getKeyedBlockChars() {
  const key = keyInput.value || "";
  if (!key) return blockChars;
  const off = await sha256ToOffset(key, blockChars.length);
  return blockChars.slice(off).concat(blockChars.slice(0, off));
}

// ================= TOKENIZER =================

// Converts string → integer tokens
function tokenize(str) {
  const out = [];
  let i = 0;

  while (i < str.length) {
    let matched = false;

    // dictionary longest-first
    for (const entry of DICT) {
      if (str.startsWith(entry, i)) {
        out.push(DICT_BASE + DICT.indexOf(entry));
        i += entry.length;
        matched = true;
        break;
      }
    }

    if (matched) continue;

    const c = str[i];
    if (c in CHAR_TO_ID) {
      out.push(CHAR_TO_ID[c]);
    } else {
      // literal passthrough using negative UTF codepoint
      out.push(-str.codePointAt(i));
    }

    i++;
  }

  return out;
}

// integer tokens → string
function detokenize(tokens) {
  let out = "";

  for (const t of tokens) {
    if (t < 0) {
      out += String.fromCodePoint(-t);
    } else if (t < DICT_BASE) {
      out += ID_TO_CHAR[t];
    } else {
      out += DICT[t - DICT_BASE];
    }
  }

  return out;
}

// ================= BITPACK =================

// Build a deterministic Huffman code for entries listed in `setsForHuffman`.
// The codebook is derived only from the `setsForHuffman` array (stable order)
// so encoder and decoder can reconstruct it without transmitting the table.
function buildDeterministicHuffmanMap() {
  // map set-entry -> single token (only include entries that tokenize to a single token)
  const entries = [];
  for (let i = 0; i < setsForHuffman.length; i++) {
    const s = setsForHuffman[i];
    const toks = tokenize(s);
    if (toks.length !== 1) continue; // skip multi-token entries
    const token = toks[0];
    if (token < 0) continue; // skip literal-only
    entries.push({ token, weight: setsForHuffman.length - i }); // heavier weight for earlier (more frequent)
  }

  if (entries.length === 0) return { byToken: new Map(), byLen: new Map(), maxLen: 0 };

  // single-entry: assign a 1-bit code so marker+code is unambiguous
  if (entries.length === 1) {
    const byToken = new Map();
    byToken.set(entries[0].token, { code: 0, len: 1 });
    const byLen = new Map([[1, new Map([[0, entries[0].token]])]]);
    return { byToken, byLen, maxLen: 1 };
  }

  // build Huffman tree (deterministic because weights are deterministic)
  const nodes = entries.map(e => ({ token: e.token, w: e.weight }));
  while (nodes.length > 1) {
    nodes.sort((a,b) => a.w - b.w || (a.token || 0) - (b.token || 0));
    const a = nodes.shift();
    const b = nodes.shift();
    nodes.push({ left: a, right: b, w: a.w + b.w });
  }

  const root = nodes[0];
  const byToken = new Map();

  function walk(n, codeInt, len) {
    if (!n) return;
    if (n.token !== undefined) {
      byToken.set(n.token, { code: codeInt, len });
      return;
    }
    // left -> 0, right -> 1 (MSB-first)
    walk(n.left, (codeInt << 1) | 0, len + 1);
    walk(n.right, (codeInt << 1) | 1, len + 1);
  }

  walk(root, 0, 0);

  // invert into maps by length for fast prefix matching during decode
  const byLen = new Map();
  let maxLen = 0;
  for (const [token, { code, len }] of byToken.entries()) {
    if (!byLen.has(len)) byLen.set(len, new Map());
    byLen.get(len).set(code, token);
    if (len > maxLen) maxLen = len;
  }

  return { byToken, byLen, maxLen };
}

async function encodeToBlocks(input) {
  const keyed = await getKeyedBlockChars();

  const tokens = tokenize(input);

  const maxToken = DICT_BASE + DICT.length;
  const bitsPerToken = Math.ceil(Math.log2(maxToken));
  const bitsPerBlock = Math.floor(Math.log2(keyed.length));

  // deterministic Huffman map (reconstructed by decoder)
  const hmap = buildDeterministicHuffmanMap();

  let buf = 0n;
  let bits = 0n;
  let out = "";

  const writeBits = (value, n) => {
    // write `n` bits of `value`, MSB-first
    if (n === 0) return;
    buf = (buf << BigInt(n)) | BigInt(value & ((1 << n) - 1));
    bits += BigInt(n);
    while (bits >= BigInt(bitsPerBlock)) {
      bits -= BigInt(bitsPerBlock);
      out += keyed[Number((buf >> bits) & BigInt((1 << bitsPerBlock) - 1))];
    }
  };

  for (const t of tokens) {
    if (t < 0) {
      // flush partial buffer and emit literal
      while (bits >= BigInt(bitsPerBlock)) {
        bits -= BigInt(bitsPerBlock);
        out += keyed[Number((buf >> bits) & BigInt((1 << bitsPerBlock) - 1))];
      }
      buf = 0n;
      bits = 0n;
      out += String.fromCodePoint(-t);
      continue;
    }

    const h = hmap.byToken.get(t);
    if (h) {
      // 1-bit marker + variable-length Huffman code
      writeBits(1, 1);
      writeBits(h.code, h.len);
    } else {
      // 0-bit marker + fixed-width token
      writeBits(0, 1);
      writeBits(t, bitsPerToken);
    }
  }

  if (bits > 0n) {
    out += keyed[Number((buf << (BigInt(bitsPerBlock) - bits)) & BigInt((1 << bitsPerBlock) - 1))];
  }

  return out;
}

async function decodeFromBlocks(str) {
  const keyed = await getKeyedBlockChars();
  const map = Object.fromEntries(keyed.map((c,i)=>[c,i]));

  const maxToken = DICT_BASE + DICT.length;
  const bitsPerToken = Math.ceil(Math.log2(maxToken));
  const bitsPerBlock = Math.floor(Math.log2(keyed.length));

  const hmap = buildDeterministicHuffmanMap();

  let buf = 0n;
  let bits = 0n;
  const tokens = [];

  // helper to attempt consuming encoded units from the current buf/bits
  function tryConsumeFromBuffer() {
    // we will operate on a shadow pointer so we only commit when a full unit is available
    let shadowBits = bits;
    while (true) {
      // need at least 1 bit for the Huffman marker
      if (shadowBits < 1n) return false;
      // peek the marker (MSB-first)
      const marker = Number((buf >> (shadowBits - 1n)) & 1n);

      if (marker === 0) {
        // need 1 + bitsPerToken bits total
        if (shadowBits < 1n + BigInt(bitsPerToken)) return false;
        // consume marker
        shadowBits -= 1n;
        // extract token
        const token = Number((buf >> (shadowBits - BigInt(bitsPerToken))) & BigInt((1 << bitsPerToken) - 1));
        shadowBits -= BigInt(bitsPerToken);
        // commit
        bits = shadowBits;
        tokens.push(token);
        continue; // try to consume more
      }

      // marker === 1 -> Huffman code follows (variable length)
      // we need to try lengths up to hmap.maxLen; if not enough bits yet, wait for more input
      let matched = false;
      let acc = 0;
      // we will only read ahead if there are enough bits to form at least one code length
      for (let l = 1; l <= hmap.maxLen; l++) {
        if (shadowBits < 1n + BigInt(l)) break; // not enough bits to test length l
        // peek the l-th bit (we haven't consumed the marker yet here in the peek)
        // compute acc from the next `l` bits after the marker
        let accVal = 0;
        for (let k = 0; k < l; k++) {
          const bitPos = Number(shadowBits - 1n - BigInt(k));
          const b = Number((buf >> BigInt(bitPos)) & 1n);
          accVal = (accVal << 1) | b;
        }
        const mp = hmap.byLen.get(l);
        if (mp && mp.has(accVal)) {
          // we have a match; commit consumption: marker + l bits
          shadowBits -= 1n; // marker
          shadowBits -= BigInt(l);
          bits = shadowBits;
          tokens.push(mp.get(accVal));
          matched = true;
          break;
        }
      }

      if (!matched) return false; // need more bits to decide
    }
  }

  for (const c of str) {
    if (!(c in map)) {
      // literal passthrough: commit any full tokens we can, then flush remainder and emit literal
      // (decoder mirrors encoder behavior)
      // try to consume any whole units first
      tryConsumeFromBuffer();

      // reset buffer (partial bits cannot cross a literal in this format)
      buf = 0n;
      bits = 0n;
      tokens.push(-c.codePointAt(0));
      continue;
    }

    buf = (buf << BigInt(bitsPerBlock)) | BigInt(map[c]);
    bits += BigInt(bitsPerBlock);

    // repeatedly consume as many encoded units as possible
    tryConsumeFromBuffer();
  }

  return detokenize(tokens);
}
// ================= UI =================

const textInput = document.getElementById("textInput");
const encodedOutput = document.getElementById("encodedOutput");
const keyInput = document.getElementById("keyInput");
const successIndicator = document.getElementById("successIndicator");

const inputCount = document.getElementById("inputCount");
const encodedCount = document.getElementById("encodedCount");
const compressionStats = document.getElementById("compressionStats");
const originalSize = document.getElementById("originalSize");
const encodedSize = document.getElementById("encodedSize");
const compressionPercent = document.getElementById("compressionPercent");

// small debounce helper to avoid flooding the encoder/decoder on fast typing
function debounce(fn, ms = 250) {
  let t;
  return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), ms); };
}

let _suppress = false; // prevent programmatic updates from retriggering handlers

// count user-perceived characters (grapheme clusters) — falls back to code-point counting
function countChars(str) {
  if (!str) return 0;
  // prefer Intl.Segmenter when available (accurate grapheme clusters)
  if (typeof Intl !== 'undefined' && Intl.Segmenter) {
    const seg = new Intl.Segmenter(undefined, { granularity: 'grapheme' });
    let n = 0;
    // iterate without allocating large arrays for big inputs
    for (const _ of seg.segment(str)) n++;
    return n;
  }
  // reasonable fallback: count code points (handles astral plane)
  return Array.from(str).length;
}

function updateCharCount(element, countElement) {
  const count = countChars(element.value);
  countElement.textContent = `${count.toLocaleString()} character${count !== 1 ? 's' : ''}`;
}

// accepts either strings or numeric counts (for backward compatibility)
function updateCompressionStats(original, encoded) {
  const originalLen = typeof original === 'number' ? original : countChars(String(original));
  const encodedLen = typeof encoded === 'number' ? encoded : countChars(String(encoded));

  if (originalLen === 0 || encodedLen === 0) {
    compressionStats.classList.remove('visible');
    return;
  }

  originalSize.textContent = `${originalLen.toLocaleString()} chars`;
  encodedSize.textContent = `${encodedLen.toLocaleString()} chars`;

  const ratio = ((encodedLen - originalLen) / Math.max(1, originalLen)) * 100;
  const percent = Math.abs(ratio).toFixed(1);

  if (ratio < 0) {
    compressionPercent.textContent = `${percent}% smaller`;
    compressionPercent.className = 'stat-value positive';
  } else {
    compressionPercent.textContent = `${percent}% larger`;
    compressionPercent.className = 'stat-value negative';
  }

  compressionStats.classList.add('visible');
}

async function liveEncodeFromInput() {
  if (_suppress) return;
  const src = textInput.value;
  if (!src) {
    _suppress = true;
    encodedOutput.value = '';
    updateCharCount(encodedOutput, encodedCount);
    updateCompressionStats(0, 0);
    _suppress = false;
    return;
  }

  _suppress = true;
  try {
    localStorage.setItem("blockEncoderKey", keyInput.value);
    const encoded = await encodeToBlocks(src);
    encodedOutput.value = encoded;
    updateCharCount(encodedOutput, encodedCount);
    updateCompressionStats(src, encoded);
  } finally {
    _suppress = false;
  }
}

async function liveDecodeFromEncoded() {
  if (_suppress) return;
  const src = encodedOutput.value;
  if (!src) {
    _suppress = true;
    textInput.value = '';
    updateCharCount(textInput, inputCount);
    updateCompressionStats(0, 0);
    _suppress = false;
    return;
  }

  _suppress = true;
  try {
    localStorage.setItem("blockEncoderKey", keyInput.value);
    const decoded = await decodeFromBlocks(src);
    // update the human-readable input
    textInput.value = decoded;
    updateCharCount(textInput, inputCount);
    updateCompressionStats(decoded, src);
  } finally {
    _suppress = false;
  }
}

const debouncedEncode = debounce(liveEncodeFromInput, 220);
const debouncedDecode = debounce(liveDecodeFromEncoded, 220);

// wire up two-way live conversion (only trigger when user edits the field)
textInput.addEventListener('input', (ev) => {
  if (document.activeElement !== textInput) return;
  debouncedEncode();
});

encodedOutput.addEventListener('input', (ev) => {
  if (document.activeElement !== encodedOutput) return;
  debouncedDecode();
});

// re-run appropriate transform when key changes
keyInput.addEventListener('input', debounce(() => {
  if (document.activeElement === encodedOutput) debouncedDecode();
  else debouncedEncode();
}, 260));

function showSuccess() {
  successIndicator.classList.add('show');
  setTimeout(() => {
    successIndicator.classList.remove('show');
  }, 1400);
}

// initialize counts + load saved key
const savedKey = localStorage.getItem("blockEncoderKey");
if (savedKey) { keyInput.value = savedKey; }
updateCharCount(textInput, inputCount);
updateCharCount(encodedOutput, encodedCount);

// if there is pre-filled content, run an initial conversion
if (encodedOutput.value) {
  debouncedDecode();
} else if (textInput.value) {
  debouncedEncode();
}

</script>

</body>
</html>
